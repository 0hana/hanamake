#!/bin/sh
#  Copyright (C) 2022 Hanami Zero
#
#  This file is part of hanamake,
#  a C and C++ development utility.
#
#  hanamake is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License --
#  the superset of version 3 of the GNU General Public License --
#  as published by the Free Software Foundation.
#
#  hanamake is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty
#  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU Affero General Public License for more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with hanamake. If not, see <https://www.gnu.org/licenses/>.

Usage="Usage: hanamake [ -s <source-directory> ] ... [ build | clean | debug ]"


#  Enforce printing an exit message for non-zero exit codes

trap 'if ! test ${?} -eq 0; then 1>&2 printf "\nhanamake:  Exiting.\n"; fi' EXIT


#  Define a function to print a notice that the name 'hanamade' is reserved

print_hanamade_reservation_notice()
{
  1>&2 echo "hanamake:  the file-path name 'hanamade' is reserved by hanamake."
  1>&2 echo
  1>&2 echo "           However, if you need to use that name for some reason,"
  1>&2 echo "           the POSIX shell script that requires it--"
  1>&2 echo
  1>&2 echo "           '$(realpath -P "$(command -v hanamake)")'"
  1>&2 echo
  1>&2 echo "           --can be patched to use a different name. Note that"
  1>&2 echo "           THIS IS NOT SUPPORTED and is only a suggestion if"
  1>&2 echo "           you find yourself in a bind."
  1>&2 echo
  1>&2 echo "           Disclaimer aside,"
  1>&2 echo "           such a patch might be automated via a stream edit:"
  1>&2 echo
  1>&2 echo "           cp \\"
  1>&2 echo "           '$(realpath -P "$(command -v hanamake)")' \\"
  1>&2 echo "           '$(realpath -P "$(command -v hanamake)")'.bup"
  1>&2 echo "           sed -i 's/ hanamade/ some-other-name/g' \\"
  1>&2 echo "           '$(realpath -P "$(command -v hanamake)")'"
  1>&2 echo
  1>&2 echo "           And if later needed, undone by backup restoration:"
  1>&2 echo
  1>&2 echo "           mv \\"
  1>&2 echo "           '$(realpath -P "$(command -v hanamake)")'.bup \\"
  1>&2 echo "           '$(realpath -P "$(command -v hanamake)")'"
}


#  Make a workspace to store everything that will be made
#  (for easy organization and clean up)

if ! mkdir -p hanamade  # If 'hanamade' directory neither exists nor can be made
then                    # Then notify the user and exit the program

  print_hanamade_reservation_notice

  exit 255                # exit with error code -1 (256-1), ending the program
                          #
fi                      # Finish (end of conditional workspace creation)


#  Change directory into the workspace

cd hanamade


#  If hanamake was run previously, there should be a directory containing
#  symbolic links to all the then specified source directories--delete it

if test -d source-link  # Does a directory named 'source-link' exist?
then rm -r source-link  # Then remove it and all its contents
fi                      # Finish (end of conditional removal)


#  Make a new source-link directory, and scan the text of the user issued
#  hanamake command to determine if any source directories were specified
#  --otherwise, use the default name 'source'

mkdir source-link

first() { echo "${1}" | cut -c 1; }  # Define a function called 'first' that
                                     # gets the first character from the 1st
                                     # word after it

while test ${#} -gt 1  # While the number of parameters is greater than 1
do                     # Do the following:
                         #
  if ! test "${1}" = -s  # If the 1st parameter is NOT '-s'
                         # (When there are multiple parameters)
                         #
  then                   # Then (the user has made an error)
                           #
    1>&2 echo "${Usage}"   # echo the supported command usage text
    exit 1                 # terminate the program
                           #
  else                   # Otherwise (the user has specified a source-directory)
                           #
                           # (The backslash denotes a line continuation)
    if test \
    "$(first "${2}")" = -  # If the first character of the 2nd parameter is '-'
    then                   # Then (the user made an error entering the command)
                             #
      1>&2 echo "${Usage}"   # echo the supported command usage text
      exit 2                 # terminate the program
                             #
    elif test "${2}" = /   # Otherwise, if the 2nd parameter is a slash, '/',
    then                   # Then (since the program is unable to process root)

      1>&2 echo "hanamake:  cannot process '/' as a source directory"
      exit 3

    fi                     # Finish (end of inner inner conditional)

    # So far,
    # the user has not made a command syntax error,
    # but we must still check for a semantic error:
    # If they specified a directory, does a directory by that name exist?
    #
    # Temporarily change back out of the 'hanamade' directory to get the
    # realpath name of the specified directory

    cd ..
    realpath="$(2>/dev/null realpath "${2}")"

    # Change back into 'hanamade'

    cd hanamade


    issue="hakuna matata"


    # Does the realpath of ${2} name a directory?
    if ! test -d "${realpath}"; then issue="is not a directory"; fi

    # Does the realpath of ${2} even exist?
    if ! test -e "${realpath}"; then issue="does not exist"; fi

    if ! test "${issue}" = "hakuna matata"   # If things are not "hakuna matata"
    then                                     # Then notify the user

      1>&2 echo "hanamake:  specified <source-directory> '${2}'"
      1>&2 echo "           ${issue}."
                                             #
      exit 4                                 # and terminate the program
                                             #
    else                                     # Otherwise

      mkdir -p "source-link$(dirname "${realpath}")"

      if test -L "source-link${realpath}"    # Does this symbolic link already
                                             # exist?
      then                                   # Then notify the user
                                             # and terminate the program
                                             #
        issue="cannot process duplicate <source-directory> inputs"
        1>&2 echo "hanamake:  ${issue}."
        1>&2 echo "           (duplicate was '${2}')"
        exit 5
                                             #
      fi                                     # Fi

      ln -s "${realpath}" "source-link${realpath}"  # Make the link

      # Explanation:
      #
      # 'realpath' will get the path from '/' to ${2}, e.g. '/X/Y/Z'
      # (of chief importance, the string WILL begin with '/')
      # So the string "$(realpath ${2})" will always begin with '/'
      #
      # 'dirname' removes the final file-path component of the string
      # 'dirname /X/Y/Z' results in '/X/Y'
      # 'dirname /X/Y/Z/' ALSO RESULTS IN '/X/Y'
      #
      # EMPHASIS, 'dirname /Z/' RESULTS IN '/'
      #
      # If you didn't understand the significance of the above explanation,
      # read it again--it's easy to miss.
      #
      # Thus no matter what the user specifies, a directory mirroring
      # the path to the parent directory of their specified directory
      # will be created as a sub-directory of source-link
      #
      # For example,
      # 'hanamake -s /their/directory' will create 'source-link/their',
      # and so too will:
      # 'hanamake -s /their/directory/'
      #
      # Lastly, we make a symbolic link to the realpath of the specified
      # directory, from a mirrored path under source-link

    fi                                       # Fi
                         # # # # # # # # # # #
  fi                     # Fi
                         #
  shift 2                # Replace the first 2 parameters with the next 2
                         #
done                   # If the condition for 'while' at the top of the loop is
                       # false
                       # --
                       #   when the number of parameters remaining is
                       #   less than 2
                       # --
                       # then proceed onward. Otherwise repeat the loop.
                       # Each loop will reduce the parameters remaining by 2.
